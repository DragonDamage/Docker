# :whale: Docker 

## :pushpin: Основные понятия:
| Docker | Это открытая платформа, которая позволяет автоматизировать развертывание, масштабирование и управление приложениями с помощью контейнеризации. Контейнеры Docker представляют собой легковесные и изолированные окружения, в которых можно запускать приложения и их зависимости. |
| :---: | :---: |
| **Docker контейнеры** | Представляют собой исполняемые единицы программного обеспечения, которые включают в себя все необходимое для запуска приложения, включая код, системные библиотеки, среду выполнения и зависимости. Контейнеры обеспечивают изоляцию и портативность, что позволяет запускать приложения в любой среде, где установлен Docker. |
| **Образы Docker (Docker Image)** | Являются шаблонами для создания контейнеров. Они содержат все необходимые компоненты, включая операционную систему, приложение и его зависимости. Образы можно создавать самостоятельно или использовать готовые образы, доступные в Docker Hub - центральном репозитории образов Docker. |
| **Docker daemon (dockerd)** | Это основной компонент Docker, который отвечает за управление контейнерами и выполнение команд Docker. Он работает как фоновый процесс на хостовой операционной системе и прослушивает API запросы от Docker клиента. |
| **Docker Hub/ Docker registry**  | Это облачный репозиторий образов Docker, где разработчики могут делиться своими образами и использовать образы, созданные другими сообществами. Docker Hub также предоставляет функциональность для автоматической сборки и публикации образов из репозиториев кода, таких как GitHub. |
| **Dockerfile**        | Это текстовый файл, в котором определяется конфигурация образа Docker. В Dockerfile вы указываете инструкции для создания образа, такие как установка зависимостей, копирование файлов, настройка сети и другие операции. Затем Dockerfile используется для создания образа с помощью команды docker build. |
| **Docker Compose**    | Это инструмент для определения и управления многоконтейнерными приложениями. С помощью файла конфигурации YAML вы можете определить несколько контейнеров, их зависимости и настройки сети. Затем Docker Compose позволяет легко запускать и остановить все контейнеры одной командой. |

![Screenshot](Docker_Architecture.png)


## :dart: Чем Docker отличается от виртуальной машины (виртуалки):
**В целом, Docker предоставляет более легковесный и гибкий подход к развертыванию и управлению приложениями, в то время как виртуальные машины обеспечивают полную изоляцию и независимость операционных систем. Выбор между Docker и виртуалками зависит от конкретных требований вашего проекта.**
| Уровень изоляции | Виртуальные машины полностью эмулируют аппаратное обеспечение и каждая виртуальная машина имеет свою собственную операционную систему. Docker использует контейнеризацию, которая позволяет запускать приложения в изолированных контейнерах, но все контейнеры используют общую операционную систему хоста. Это делает контейнеры более легковесными и быстрыми в запуске по сравнению с виртуалками. |
| :---: | :---: |
| **Уровень изоляции** | Виртуальные машины полностью эмулируют аппаратное обеспечение и каждая виртуальная машина имеет свою собственную операционную систему. Docker использует контейнеризацию, которая позволяет запускать приложения в изолированных контейнерах, но все контейнеры используют общую операционную систему хоста. Это делает контейнеры более легковесными и быстрыми в запуске по сравнению с виртуалками. |
| **Ресурсы** | Виртуальные машины требуют выделения отдельных ресурсов, таких как память и процессорное время, для каждой виртуальной машины. Docker контейнеры используют общие ресурсы хоста, что делает их более эффективными в использовании ресурсов. |
| **Размер и скорость** | Виртуальные машины обычно занимают гигабайты дискового пространства и требуют значительного времени для запуска. Docker контейнеры, с другой стороны, могут быть гораздо меньше и запускаться практически мгновенно. |
| **Управление** | Docker предоставляет инструменты для управления контейнерами, такими как Docker CLI и Docker Compose. Виртуальные машины требуют отдельного управления каждой виртуальной машиной, например, с помощью гипервизора или оркестратора виртуальных машин. |
| **Портативность** | Docker контейнеры являются портативными и могут быть запущены на любой системе, поддерживающей Docker. Виртуальные машины, с другой стороны, требуют наличия гипервизора, который может быть разным для разных операционных систем. |


## :computer: Инструкция по установке Docker на Linux:
```ruby
$ apt-get update                       # Обновляемся
$ apt-get install apt-transport-https  # Устанавливаем https протокол
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add  # Добавить ключ
$ add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"  # Актуализировать версию
$ apt-get update                 # Ещё раз обновляемся
$ apt-get install docker-ce      # Устанавливаем docker
$ systemctl status docker        # Проверяем процесс докера
$ sudo usermod -aG docker $USER  # Можно добавить юзера, как рута (optional)
```

## :vhs: Основные команды:
```ruby
$ docker run {image name}     # Запустить/скачать docker "image" test
$ docker images               # Показать "образы", которые есть
$ docker ps                   # Показать запущенные "контейнеры"
$ docker ps -a                # Показать "контейнеры", которые были запущены
$ docker search {image name}  # Произвести поиск в консоли по Docker-Hub
$ docker pull {image name}    # Скачать "image" tomcat
$ docker push {image name}    # Загрузить образ в Docker-Hub
$ docker run -it -p 8080 {image name}    # Запустить "контейнер" it(интерактивно в консоли), p(порт веб-сервера 8080), томкэт
http://192.168.197.128:8080/             # Идём тестить в браузер (ip естественно ваш вставляем)
$ docker run -d -p 8080 {image name}     # Запустить "контейнер" deamon (как процесс)
$ docker run -d -p 8888:80 {image name}  # Запустить "контейнер" deamon (как процесс), p(делаем переброс порта веб-сервера с 80 на 8888), nginx
$ docker stop {CONTAINER ID}             # Остановить "контейнер" CONTAINER ID
$ docker rm {CONTAINER ID}               # Удалить "контейнер" CONTAINER ID (который не используется)
$ docker rmi {image name}                # Удалить "образ" REPOSITORY
$ docker network ls               # Посмотреть сети подключения докера
$ lsof -i -P -n  | grep docker    # Посмотреть открытые порты докера
$ docker start {CONTAINER ID}     # Запустить контейнер
$ docker start -a {CONTAINER ID}  # Запустить контейнер и сразу смотреть по нему логи
$ docker logs {CONTAINER ID}      # Посмотреть логи контейнера
$ docker exec {CONTAINER ID}      # Запустить команду внутри контейнера
$ docker stop {CONTAINER ID}      # Остановить контейнер
$ docker stop $(docker ps -a -q)  # Остановить все контейнеры
$ docker kill {CONTAINER ID}      # Резко остановить контейнер
$ docker build -t {image name} {path-to-dockerfile}   # Создать образ из Dockerfile (./path/to/dockerfile)
```


## Пример Dockerfile:
```ruby
# Используем базовый образ Ubuntu
FROM ubuntu:latest

# Устанавливаем необходимые пакеты
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip

# Копируем файлы в контейнер
COPY . /app

# Устанавливаем зависимости
RUN pip3 install -r /app/requirements.txt

# Определяем рабочую директорию
WORKDIR /app

# Определяем команду, которая будет выполняться при запуске контейнера
CMD ["python3", "app.py"]
```

```docker build -t my-app .``` - Собираем Docker образ

```docker run -d -p 8080:8080 my-app``` - Запускаем контейнер

Теперь приложение будет доступно по адресу http://localhost:8080

